[
  {
    "id": "reflection",
    "title": "Reflection Loop",
    "title_ko": "반성 루프 패턴",
    "category": "Feedback Loops",
    "status": "established",
    "tags": ["self-feedback", "iterative-improvement", "evaluation"],
    "source": "https://arxiv.org/abs/2303.11366",
    "problem": { "en": "LLM outputs may contain errors or suboptimal solutions without self-correction mechanisms.", "ko": "LLM 출력이 자기 수정 메커니즘 없이 오류나 차선의 솔루션을 포함할 수 있습니다." },
    "solution": { "en": "Agent reviews and critiques its own outputs, iteratively improving until quality thresholds are met.", "ko": "에이전트가 자신의 출력을 검토하고 비판하여 품질 임계값에 도달할 때까지 반복적으로 개선합니다." },
    "ascii_diagram": "┌─────────────┐\n│   Agent     │\n└──────┬──────┘\n       │ generate\n       ▼\n┌─────────────┐\n│   Output    │\n└──────┬──────┘\n       │ critique\n       ▼\n┌─────────────┐\n│  Self-Eval  │\n└──────┬──────┘\n       │ improve?\n   ┌───┴───┐\n   ▼       ▼\n [Yes]   [No]\n   │       │\n   │       ▼\n   │   ┌───────┐\n   │   │ Final │\n   │   └───────┘\n   └──────▲",
    "mermaid_diagram": "flowchart TD\n    A[Generate Output] --> B[Self-Critique]\n    B --> C{Good Enough?}\n    C -->|No| D[Improve]\n    D --> A\n    C -->|Yes| E[Final Output]",
    "when_to_use_ko": ["코드 생성 품질 향상", "글쓰기 개선", "복잡한 추론 검증"],
    "pros_ko": ["출력 품질 향상", "오류 자동 감지", "추가 모델 불필요"],
    "cons_ko": ["지연 시간 증가", "토큰 비용 증가", "무한 루프 위험"]
  },
  {
    "id": "plan-then-execute-pattern",
    "title": "Plan-Then-Execute Pattern",
    "title_ko": "계획 후 실행 패턴",
    "category": "Orchestration & Control",
    "status": "emerging",
    "tags": ["planning", "control-flow-integrity", "prompt-injection"],
    "source": "https://arxiv.org/abs/2506.08837",
    "problem": { "en": "Agents that plan and execute simultaneously are vulnerable to prompt injection mid-execution.", "ko": "계획과 실행을 동시에 수행하는 에이전트는 실행 중 프롬프트 인젝션에 취약합니다." },
    "solution": { "en": "Separate planning phase from execution, locking the plan before any untrusted data processing.", "ko": "계획 단계를 실행과 분리하고, 신뢰할 수 없는 데이터 처리 전에 계획을 잠급니다." },
    "ascii_diagram": "┌─────────────┐\n│   Task      │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│   PLAN      │\n│  (locked)   │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│  EXECUTE    │\n│ (no modify) │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│   Result    │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Task] --> B[Planning Phase]\n    B -->|Lock Plan| C[Execution Phase]\n    C --> D[Result]\n    E[Untrusted Data] -->|Cannot modify| B",
    "when_to_use_ko": ["보안 민감 에이전트", "다단계 작업", "외부 입력 처리"],
    "pros_ko": ["프롬프트 인젝션 방어", "예측 가능한 실행", "감사 가능"],
    "cons_ko": ["유연성 감소", "동적 적응 어려움"]
  },
  {
    "id": "dual-llm-pattern",
    "title": "Dual LLM Pattern",
    "title_ko": "이중 LLM 패턴",
    "category": "Orchestration & Control",
    "status": "emerging",
    "tags": ["privilege-separation", "quarantined-llm", "symbolic-variables"],
    "source": "https://arxiv.org/abs/2506.08837",
    "problem": { "en": "A single LLM processing both trusted and untrusted data is vulnerable to prompt injection.", "ko": "신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 모두 처리하는 단일 LLM은 프롬프트 인젝션에 취약합니다." },
    "solution": { "en": "Use two LLMs: a privileged one for planning/tools and a quarantined one for untrusted data.", "ko": "두 개의 LLM 사용: 계획/도구용 권한 있는 LLM과 신뢰할 수 없는 데이터용 격리된 LLM." },
    "ascii_diagram": "┌─────────────────────────────┐\n│      Privileged LLM         │\n│   (tools, planning)         │\n└──────────────┬──────────────┘\n               │\n      ┌────────┴────────┐\n      ▼                 ▼\n┌──────────┐     ┌──────────┐\n│  Tools   │     │Quarantine│\n│          │     │   LLM    │\n└──────────┘     └────┬─────┘\n                      │\n               ┌──────▼──────┐\n               │  Untrusted  │\n               │    Data     │\n               └─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Privileged LLM] -->|control| B[Tools]\n    A -->|delegate| C[Quarantined LLM]\n    C -->|process| D[Untrusted Data]\n    D -->|sanitized| A",
    "when_to_use_ko": ["이메일/문서 처리", "웹 스크래핑", "사용자 입력 처리"],
    "pros_ko": ["보안 분리", "공격 표면 축소", "권한 최소화"],
    "cons_ko": ["복잡한 아키텍처", "비용 증가", "지연 시간"]
  },
  {
    "id": "sub-agent-spawning",
    "title": "Sub-Agent Spawning",
    "title_ko": "서브 에이전트 생성 패턴",
    "category": "Orchestration & Control",
    "status": "validated-in-production",
    "tags": ["orchestration", "context", "scalability", "subagents"],
    "source": "https://www.nibzard.com/ampcode",
    "problem": { "en": "Complex tasks exceed single agent context limits and require specialized handling.", "ko": "복잡한 작업이 단일 에이전트 컨텍스트 한계를 초과하고 전문화된 처리가 필요합니다." },
    "solution": { "en": "Main agent spawns specialized sub-agents for specific subtasks with focused context.", "ko": "메인 에이전트가 집중된 컨텍스트로 특정 하위 작업을 위한 전문화된 서브 에이전트를 생성합니다." },
    "ascii_diagram": "┌─────────────────┐\n│   Main Agent    │\n└────────┬────────┘\n    ┌────┼────┐\n    ▼    ▼    ▼\n┌─────┐┌─────┐┌─────┐\n│Sub1 ││Sub2 ││Sub3 │\n│Code ││Test ││Docs │\n└──┬──┘└──┬──┘└──┬──┘\n   └──────┼──────┘\n          ▼\n   ┌────────────┐\n   │  Combine   │\n   └────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Main Agent] --> B[Sub-Agent: Code]\n    A --> C[Sub-Agent: Test]\n    A --> D[Sub-Agent: Docs]\n    B & C & D --> E[Aggregate Results]",
    "when_to_use_ko": ["대규모 코드베이스 작업", "병렬 처리 필요 시", "전문화된 작업 분리"],
    "pros_ko": ["컨텍스트 분리", "병렬 처리", "전문화"],
    "cons_ko": ["조정 오버헤드", "비용 증가", "결과 통합 복잡"]
  },
  {
    "id": "human-in-loop-approval-framework",
    "title": "Human-in-the-Loop Approval Framework",
    "title_ko": "휴먼 인 더 루프 승인 프레임워크",
    "category": "UX & Collaboration",
    "status": "validated-in-production",
    "tags": ["human-oversight", "safety", "approvals", "risk-management"],
    "source": "https://claude.com/blog/building-companies-with-claude-code",
    "problem": { "en": "Fully autonomous agents may take risky actions without human oversight.", "ko": "완전 자율 에이전트가 인간의 감독 없이 위험한 행동을 취할 수 있습니다." },
    "solution": { "en": "Route high-risk operations through human approval gates via Slack, email, or other channels.", "ko": "고위험 작업을 Slack, 이메일 또는 기타 채널을 통해 인간 승인 게이트로 라우팅합니다." },
    "ascii_diagram": "┌─────────────┐\n│   Agent     │\n└──────┬──────┘\n       │ action\n┌──────▼──────┐\n│ Risk Check  │\n└──────┬──────┘\n   ┌───┴───┐\n   ▼       ▼\n[Low]    [High]\n   │       │\n   │  ┌────▼────┐\n   │  │  Human  │\n   │  │ Approve │\n   │  └────┬────┘\n   │       │\n   └───┬───┘\n┌──────▼──────┐\n│   Execute   │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Agent Action] --> B{Risk Level}\n    B -->|Low| C[Auto Execute]\n    B -->|High| D[Human Approval]\n    D -->|Approve| C\n    D -->|Reject| E[Cancel]",
    "when_to_use_ko": ["프로덕션 배포", "금융 거래", "삭제/수정 작업"],
    "pros_ko": ["안전성 향상", "감사 추적", "신뢰 구축"],
    "cons_ko": ["지연 시간", "인간 병목", "24/7 커버리지 필요"]
  },
  {
    "id": "tree-of-thought-reasoning",
    "title": "Tree-of-Thought Reasoning",
    "title_ko": "생각의 나무 추론",
    "category": "Orchestration & Control",
    "status": "established",
    "tags": ["branching", "deliberate-reasoning", "search"],
    "source": "https://arxiv.org/abs/2305.10601",
    "problem": { "en": "Linear chain-of-thought limits exploration of alternative solution paths.", "ko": "선형 사고 연쇄가 대안적 솔루션 경로 탐색을 제한합니다." },
    "solution": { "en": "Explore multiple reasoning branches in parallel, evaluating and pruning paths systematically.", "ko": "여러 추론 분기를 병렬로 탐색하고, 체계적으로 경로를 평가하고 가지치기합니다." },
    "ascii_diagram": "         ┌───────┐\n         │Problem│\n         └───┬───┘\n        ┌────┼────┐\n        ▼    ▼    ▼\n      ┌───┐┌───┐┌───┐\n      │ A ││ B ││ C │\n      └─┬─┘└─┬─┘└─┬─┘\n       ┌┴┐  ┌┴┐   ✗\n       ▼ ▼  ▼ ▼\n      A1 A2 B1 B2\n       ✓  ✗  ✓  ✗\n       │     │\n       └──┬──┘\n       ┌──▼──┐\n       │Best │\n       └─────┘",
    "mermaid_diagram": "flowchart TD\n    A[Problem] --> B[Branch A]\n    A --> C[Branch B]\n    A --> D[Branch C]\n    B --> E[Evaluate]\n    C --> F[Evaluate]\n    D --> G[Prune]\n    E & F --> H[Select Best]",
    "when_to_use_ko": ["수학 문제", "게임 전략", "복잡한 의사결정"],
    "pros_ko": ["더 나은 솔루션 탐색", "체계적 평가", "백트래킹 가능"],
    "cons_ko": ["계산 비용 높음", "구현 복잡", "분기 폭발 위험"]
  },
  {
    "id": "graph-of-thoughts",
    "title": "Graph of Thoughts (GoT)",
    "title_ko": "생각의 그래프 (GoT)",
    "category": "Feedback Loops",
    "status": "emerging",
    "tags": ["reasoning", "graph-based", "problem-solving", "aggregation"],
    "source": "https://arxiv.org/abs/2308.09687",
    "problem": { "en": "Tree structures cannot represent thought aggregation or cycles in reasoning.", "ko": "트리 구조는 추론에서 생각 집계나 순환을 표현할 수 없습니다." },
    "solution": { "en": "Model reasoning as a graph where thoughts can merge, aggregate, and form cycles.", "ko": "생각이 병합, 집계, 순환을 형성할 수 있는 그래프로 추론을 모델링합니다." },
    "ascii_diagram": "      ┌───┐\n      │ A │\n      └─┬─┘\n     ┌──┴──┐\n     ▼     ▼\n   ┌───┐ ┌───┐\n   │ B │ │ C │\n   └─┬─┘ └─┬─┘\n     │     │\n     └──┬──┘ (merge)\n        ▼\n      ┌───┐\n      │ D │\n      └─┬─┘\n        │\n        ▼ (may cycle)",
    "mermaid_diagram": "flowchart TD\n    A[Thought A] --> B[Thought B]\n    A --> C[Thought C]\n    B --> D[Merge D]\n    C --> D\n    D -->|Refine| A",
    "when_to_use_ko": ["복잡한 문제 해결", "다중 관점 통합", "반복적 추론"],
    "pros_ko": ["유연한 추론 구조", "생각 집계 가능", "순환 추론 지원"],
    "cons_ko": ["구현 복잡도 높음", "추론 경로 추적 어려움"]
  },
  {
    "id": "context-minimization-pattern",
    "title": "Context-Minimization Pattern",
    "title_ko": "컨텍스트 최소화 패턴",
    "category": "Context & Memory",
    "status": "emerging",
    "tags": ["context-hygiene", "taint-removal", "prompt-injection"],
    "source": "https://arxiv.org/abs/2506.08837",
    "problem": { "en": "User-supplied or tainted text lingers in context, enabling later prompt injection.", "ko": "사용자 제공 또는 오염된 텍스트가 컨텍스트에 남아 이후 프롬프트 인젝션을 가능하게 합니다." },
    "solution": { "en": "Purge or redact untrusted segments once they've served their purpose.", "ko": "신뢰할 수 없는 세그먼트가 목적을 달성하면 제거하거나 수정합니다." },
    "ascii_diagram": "┌─────────────┐\n│User Prompt  │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│  Transform  │\n│  to SQL     │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│REMOVE tainted│\n│   tokens    │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│Safe context │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[User Input] --> B[Process]\n    B --> C[Remove Untrusted]\n    C --> D[Clean Context]\n    D --> E[Continue]",
    "when_to_use_ko": ["고객 서비스 챗봇", "의료 Q&A", "다중 턴 흐름"],
    "pros_ko": ["간단함", "추가 모델 불필요", "컨텍스트 불안 완화"],
    "cons_ko": ["대화 뉘앙스 손실", "UX 저하 가능"]
  },
  {
    "id": "curated-code-context-window",
    "title": "Curated Code Context Window",
    "title_ko": "큐레이션된 코드 컨텍스트 윈도우",
    "category": "Context & Memory",
    "status": "validated-in-production",
    "tags": ["context-management", "code-agent", "file-selection", "noise-reduction"],
    "source": "https://www.youtube.com/watch?v=Xkwok_XXQgw",
    "problem": { "en": "Loading all source files into context overwhelms the model with noise.", "ko": "모든 소스 파일을 컨텍스트에 로드하면 노이즈로 모델이 압도됩니다." },
    "solution": { "en": "Maintain minimal, high-signal context using search sub-agents to fetch only relevant code.", "ko": "검색 서브 에이전트를 사용하여 관련 코드만 가져오는 최소한의 고신호 컨텍스트를 유지합니다." },
    "ascii_diagram": "┌─────────────┐\n│ Main Agent  │\n│ \"Find User  │\n│  Model\"     │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│SearchSubagent│\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│Top 3 files: │\n│ user.py     │\n│ auth.py     │\n│ models.py   │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│ Inject to   │\n│  Context    │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Main Agent] -->|Query| B[Search Sub-Agent]\n    B --> C[(Code Index)]\n    C --> D[Top K Files]\n    D --> E[Inject to Context]",
    "when_to_use_ko": ["대규모 코드베이스", "멀티 파일 리팩토링", "긴 세션 작업"],
    "pros_ko": ["노이즈 감소", "토큰 효율성", "추론 명확성"],
    "cons_ko": ["인덱스 최신성 유지", "복잡한 파이프라인"]
  },
  {
    "id": "coding-agent-ci-feedback-loop",
    "title": "Coding Agent CI Feedback Loop",
    "title_ko": "코딩 에이전트 CI 피드백 루프",
    "category": "Feedback Loops",
    "status": "best-practice",
    "tags": ["CI", "coding-agent", "asynchronous", "test-driven"],
    "source": "https://www.youtube.com/watch?v=Xkwok_XXQgw",
    "problem": { "en": "Synchronous test runs block agents from parallel work.", "ko": "동기 테스트 실행이 에이전트의 병렬 작업을 차단합니다." },
    "solution": { "en": "Run agents asynchronously against CI with iterative patch refinement.", "ko": "반복적 패치 개선과 함께 CI에 대해 에이전트를 비동기적으로 실행합니다." },
    "ascii_diagram": "┌──────────┐\n│  Agent   │\n│  Commit  │\n└────┬─────┘\n     │\n┌────▼─────┐\n│   CI     │\n│  Tests   │\n└────┬─────┘\n     │ failures\n┌────▼─────┐\n│  Agent   │\n│  Patch   │\n└────┬─────┘\n     │ re-run\n     └──▶ (repeat until ✅)",
    "mermaid_diagram": "sequenceDiagram\n    Agent->>CI: Push\n    loop Until Pass\n        CI-->>Agent: Failures\n        Agent->>Code: Patch\n        Agent->>CI: Re-run\n    end\n    CI-->>Agent: ✅ Green",
    "when_to_use_ko": ["대규모 리팩토링", "자동 버그 수정", "테스트 주도 개발"],
    "pros_ko": ["효율적 컴퓨팅", "빠른 반복", "자율 수정"],
    "cons_ko": ["CI 불안정성", "보안 고려"]
  },
  {
    "id": "compounding-engineering-pattern",
    "title": "Compounding Engineering Pattern",
    "title_ko": "복리 엔지니어링 패턴",
    "category": "Learning & Adaptation",
    "status": "emerging",
    "tags": ["learning", "feedback-loops", "codification", "knowledge-sharing"],
    "source": "https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it",
    "problem": { "en": "AI agents repeat the same mistakes without systematic learning.", "ko": "AI 에이전트가 체계적 학습 없이 같은 실수를 반복합니다." },
    "solution": { "en": "Codify learnings from each feature into prompts, hooks, and commands for compounding improvement.", "ko": "각 기능에서 얻은 학습을 프롬프트, 훅, 명령으로 코드화하여 복리적 개선을 이룹니다." },
    "ascii_diagram": "┌──────────┐\n│ Feature  │\n│  Build   │\n└────┬─────┘\n     │\n┌────▼─────┐\n│ Document │\n│ Learnings│\n└────┬─────┘\n     │\n┌────▼─────┐\n│ Codify   │\n│Prompts/  │\n│ Hooks    │\n└────┬─────┘\n     │\n┌────▼─────┐\n│  Next    │\n│(Easier!) │\n└──────────┘",
    "mermaid_diagram": "flowchart LR\n    A[Build] --> B[Learn]\n    B --> C[Codify]\n    C --> D[Next Feature]\n    D -->|Faster| A",
    "when_to_use_ko": ["팀 에이전트 도입", "반복적 개발", "온보딩 개선"],
    "pros_ko": ["가속 생산성", "지식 보존", "빠른 온보딩"],
    "cons_ko": ["초기 투자", "프롬프트 유지보수"]
  },
  {
    "id": "criticgpt-style-evaluation",
    "title": "CriticGPT-Style Code Review",
    "title_ko": "CriticGPT 스타일 코드 리뷰",
    "category": "Reliability & Eval",
    "status": "validated-in-production",
    "tags": ["evaluation", "code-review", "critique", "bug-detection"],
    "source": "https://openai.com/research/criticgpt",
    "problem": { "en": "Human reviewers may miss subtle bugs in AI-generated code.", "ko": "인간 리뷰어가 AI 생성 코드의 미묘한 버그를 놓칠 수 있습니다." },
    "solution": { "en": "Deploy specialized AI models trained for code critique and evaluation.", "ko": "코드 비판 및 평가를 위해 훈련된 전문 AI 모델을 배포합니다." },
    "ascii_diagram": "┌─────────────┐\n│ AI Code     │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│ CriticGPT   │\n├─────────────┤\n│✓ Bugs       │\n│✓ Security   │\n│✓ Quality    │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│Human Review │\n│ (Focused)   │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Generated Code] --> B[CriticGPT]\n    B --> C[Bug Analysis]\n    B --> D[Security Audit]\n    C & D --> E[Report]\n    E --> F[Human Review]",
    "when_to_use_ko": ["AI 코드 리뷰", "보안 감사", "품질 게이트"],
    "pros_ko": ["일관된 검사", "24/7 가용", "미묘한 버그 감지"],
    "cons_ko": ["오탐 가능", "훈련 비용", "맥락 한계"]
  },
  {
    "id": "discrete-phase-separation",
    "title": "Discrete Phase Separation",
    "title_ko": "분리된 단계 분리",
    "category": "Orchestration & Control",
    "status": "emerging",
    "tags": ["orchestration", "planning", "research", "context-management"],
    "source": "https://claude.com/blog/building-companies-with-claude-code",
    "problem": { "en": "Mixing research, planning, and implementation degrades output quality.", "ko": "리서치, 계획, 구현을 혼합하면 출력 품질이 저하됩니다." },
    "solution": { "en": "Break workflows into isolated phases with clean handoffs and fresh contexts.", "ko": "깨끗한 핸드오프와 새로운 컨텍스트로 워크플로우를 격리된 단계로 분리합니다." },
    "ascii_diagram": "┌──────────┐\n│ Research │ (Opus)\n│  Phase   │\n└────┬─────┘\n     │ distilled findings\n┌────▼─────┐\n│ Planning │ (Opus)\n│  Phase   │\n└────┬─────┘\n     │ roadmap\n┌────▼─────┐\n│ Execute  │ (Sonnet)\n│  Phase   │\n└──────────┘",
    "mermaid_diagram": "flowchart LR\n    A[Research] -->|Findings| B[Planning]\n    B -->|Roadmap| C[Execution]\n    style A fill:#e1f5ff\n    style B fill:#fff4e1\n    style C fill:#e8f5e9",
    "when_to_use_ko": ["복잡한 기능 개발", "신규 코드베이스", "대규모 리팩토링"],
    "pros_ko": ["높은 품질", "컨텍스트 오염 방지", "모델별 강점 활용"],
    "cons_ko": ["명시적 관리 필요", "간단한 작업에 과함"]
  },
  {
    "id": "disposable-scaffolding-over-durable-features",
    "title": "Disposable Scaffolding Over Durable Features",
    "title_ko": "내구성 기능보다 일회용 스캐폴딩",
    "category": "Orchestration & Control",
    "status": "best-practice",
    "tags": ["bitter-lesson", "temporary-tooling", "adaptability"],
    "source": "https://www.sourcegraph.com",
    "problem": { "en": "Complex durable features become obsolete when better models arrive.", "ko": "복잡한 내구성 기능이 더 나은 모델이 도착하면 구식이 됩니다." },
    "solution": { "en": "Build lightweight, disposable scaffolding that can be easily discarded.", "ko": "쉽게 버릴 수 있는 가벼운 일회용 스캐폴딩을 구축합니다." },
    "ascii_diagram": "┌──────────────────┐\n│  New Model       │\n└────────┬─────────┘\n         │\n┌────────▼─────────┐\n│ Evaluate         │\n│ Scaffolding      │\n└────────┬─────────┘\n    ┌────┴────┐\n    ▼         ▼\n[Obsolete] [Keep]\n    │         │\n    ▼         │\n[Discard]     │\n              ▼\n         [Adapt]",
    "mermaid_diagram": "flowchart TD\n    A[New Model] --> B{Scaffolding Needed?}\n    B -->|Obsolete| C[Discard]\n    B -->|Still Needed| D[Keep Minimal]\n    C --> E[Rebuild Light]\n    D --> F[Adapt]",
    "when_to_use_ko": ["빠르게 변화하는 AI 환경", "모델 업그레이드 대응", "실험적 기능"],
    "pros_ko": ["민첩성", "빠른 적응", "낮은 유지비용"],
    "cons_ko": ["기술 부채", "반복 작업"]
  },
  {
    "id": "distributed-execution-cloud-workers",
    "title": "Distributed Execution with Cloud Workers",
    "title_ko": "클라우드 워커를 활용한 분산 실행",
    "category": "Orchestration & Control",
    "status": "emerging",
    "tags": ["distributed-systems", "parallelization", "cloud", "worktrees"],
    "source": "https://claude.com/blog/building-companies-with-claude-code",
    "problem": { "en": "Single-session execution cannot scale for team-wide AI code generation.", "ko": "단일 세션 실행은 팀 전체 AI 코드 생성을 확장할 수 없습니다." },
    "solution": { "en": "Run multiple Claude sessions in parallel using git worktrees and cloud workers.", "ko": "git worktree와 클라우드 워커를 사용하여 여러 Claude 세션을 병렬로 실행합니다." },
    "ascii_diagram": "┌────────────────────┐\n│   Coordinator      │\n└─────────┬──────────┘\n    ┌─────┼─────┐\n    ▼     ▼     ▼\n┌─────┐┌─────┐┌─────┐\n│W1   ││W2   ││W3   │\n│+tree││+tree││+tree│\n└──┬──┘└──┬──┘└──┬──┘\n   │      │      │\n   └──────┼──────┘\n          ▼\n     ┌─────────┐\n     │  Merge  │\n     └─────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Coordinator] --> B[Worker 1]\n    A --> C[Worker 2]\n    A --> D[Worker N]\n    B --> E[worktree-1]\n    C --> F[worktree-2]\n    D --> G[worktree-n]\n    E & F & G --> H[Merge to Main]",
    "when_to_use_ko": ["팀 규모 마이그레이션", "병렬 기능 개발", "대규모 리팩토링"],
    "pros_ko": ["대규모 병렬화", "팀 확장성", "중앙 집중 관리"],
    "cons_ko": ["인프라 복잡성", "병합 충돌", "비용 증가"]
  },
  {
    "id": "dogfooding-with-rapid-iteration-for-agent-improvement",
    "title": "Dogfooding with Rapid Iteration",
    "title_ko": "빠른 반복을 통한 도그푸딩",
    "category": "Feedback Loops",
    "status": "best-practice",
    "tags": ["dogfooding", "iterative-development", "feedback-loop"],
    "source": "https://www.youtube.com/watch?v=BGgsoIgbT_Y",
    "problem": { "en": "External feedback loops are slow and may miss real-world usage nuances.", "ko": "외부 피드백 루프가 느리고 실제 사용 뉘앙스를 놓칠 수 있습니다." },
    "solution": { "en": "Development team extensively uses their own AI agent for daily tasks.", "ko": "개발 팀이 일상 작업에 자체 AI 에이전트를 광범위하게 사용합니다." },
    "ascii_diagram": "┌──────────────┐\n│  Dev Team    │\n│  Uses Agent  │\n└──────┬───────┘\n       │\n┌──────▼───────┐\n│Find Problems │\n└──────┬───────┘\n       │\n┌──────▼───────┐\n│  Quick Fix   │\n└──────┬───────┘\n       │\n┌──────▼───────┐\n│  Validate    │\n└──────┬───────┘\n       │\n       └──▶ (repeat)",
    "mermaid_diagram": "flowchart TD\n    A[Team Uses Agent] --> B[Find Issues]\n    B --> C[Fix Quickly]\n    C --> D[Validate]\n    D --> A",
    "when_to_use_ko": ["에이전트 제품 개발", "빠른 프로토타이핑", "사용자 경험 개선"],
    "pros_ko": ["즉각적 피드백", "실제 문제 발견", "빠른 반복"],
    "cons_ko": ["편향된 사용 패턴", "내부 전문성 필요"]
  },
  {
    "id": "dual-use-tool-design",
    "title": "Dual-Use Tool Design",
    "title_ko": "이중 사용 도구 설계",
    "category": "Tool Use & Environment",
    "status": "best-practice",
    "tags": ["tools", "ux", "slash-commands", "human-ai-collaboration"],
    "source": "https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it",
    "problem": { "en": "Separate tools for humans and agents create maintenance overhead.", "ko": "인간과 에이전트를 위한 별도 도구가 유지보수 오버헤드를 생성합니다." },
    "solution": { "en": "Design all tools to be equally accessible to both humans and AI agents.", "ko": "모든 도구를 인간과 AI 에이전트 모두에게 동등하게 접근 가능하도록 설계합니다." },
    "ascii_diagram": "┌──────────────────────┐\n│   Dual-Use Tool      │\n│   /commit            │\n├──────────────────────┤\n│ Human: types /commit │\n│ Agent: calls /commit │\n│                      │\n│ Same logic, same     │\n│ behavior             │\n└──────────────────────┘",
    "mermaid_diagram": "flowchart LR\n    A[Tool: /commit] --> B[Human]\n    A --> C[Agent]\n    B -->|Same| D[Behavior]\n    C -->|Same| D",
    "when_to_use_ko": ["CLI 도구 개발", "슬래시 명령 설계", "자동화 파이프라인"],
    "pros_ko": ["유지보수 감소", "일관된 동작", "공유 개선"],
    "cons_ko": ["설계 제약", "최적화 타협"]
  },
  {
    "id": "episodic-memory-retrieval-injection",
    "title": "Episodic Memory Retrieval & Injection",
    "title_ko": "일화적 메모리 검색 및 주입",
    "category": "Context & Memory",
    "status": "validated-in-production",
    "tags": ["episodic-memory", "vector-db", "retrieval-augmented"],
    "source": "https://forum.cursor.com/t/agentic-memory-management-for-cursor/78021",
    "problem": { "en": "Agents lack persistent memory across sessions for relevant past experiences.", "ko": "에이전트가 관련 과거 경험에 대한 세션 간 영구 메모리가 부족합니다." },
    "solution": { "en": "Store and retrieve episodic memories using vector databases for context enrichment.", "ko": "컨텍스트 강화를 위해 벡터 데이터베이스를 사용하여 일화적 메모리를 저장하고 검색합니다." },
    "ascii_diagram": "┌─────────────┐\n│   Query     │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│  Embed      │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│ Vector DB   │\n│ (memories)  │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│ Top K       │\n│ Relevant    │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│ Inject to   │\n│ Context     │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Current Query] --> B[Embed]\n    B --> C[(Vector DB)]\n    C --> D[Top K Memories]\n    D --> E[Inject to Context]\n    E --> F[Enhanced Response]",
    "when_to_use_ko": ["장기 프로젝트", "개인화된 어시스턴트", "반복 작업"],
    "pros_ko": ["세션 간 연속성", "관련 맥락", "학습 효과"],
    "cons_ko": ["벡터 DB 관리", "검색 품질", "프라이버시"]
  },
  {
    "id": "filesystem-based-agent-state",
    "title": "Filesystem-Based Agent State",
    "title_ko": "파일시스템 기반 에이전트 상태",
    "category": "Context & Memory",
    "status": "established",
    "tags": ["state-management", "persistence", "resumption"],
    "source": "https://www.anthropic.com/engineering/code-execution-with-mcp",
    "problem": { "en": "Agent state is lost on crashes or long-running task interruptions.", "ko": "에이전트 상태가 충돌이나 장시간 작업 중단 시 손실됩니다." },
    "solution": { "en": "Persist agent state to filesystem for recovery and resumption.", "ko": "복구 및 재개를 위해 에이전트 상태를 파일시스템에 유지합니다." },
    "ascii_diagram": "┌─────────────┐\n│   Agent     │\n│  Running    │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│  Checkpoint │\n│  to File    │\n└──────┬──────┘\n       │\n    [crash]\n       │\n┌──────▼──────┐\n│   Restart   │\n│  from File  │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Agent] -->|Checkpoint| B[(Filesystem)]\n    B -->|Crash| C[Interrupted]\n    C -->|Restore| D[Resume Agent]\n    D --> A",
    "when_to_use_ko": ["장시간 작업", "불안정한 환경", "체크포인팅 필요"],
    "pros_ko": ["복구 가능", "상태 지속", "디버깅 용이"],
    "cons_ko": ["I/O 오버헤드", "상태 일관성", "저장 공간"]
  },
  {
    "id": "inversion-of-control",
    "title": "Inversion of Control",
    "title_ko": "제어의 역전",
    "category": "Orchestration & Control",
    "status": "validated-in-production",
    "tags": ["orchestration", "autonomy", "control"],
    "source": "https://www.nibzard.com/ampcode",
    "problem": { "en": "User-driven interaction limits agent autonomy and throughput.", "ko": "사용자 주도 상호작용이 에이전트 자율성과 처리량을 제한합니다." },
    "solution": { "en": "Let the agent drive the interaction, requesting human input only when needed.", "ko": "에이전트가 상호작용을 주도하고, 필요할 때만 인간 입력을 요청하게 합니다." },
    "ascii_diagram": "┌─────────────────────┐\n│ Traditional:        │\n│ Human → Agent →     │\n│ Human → Agent → ... │\n└─────────────────────┘\n         vs\n┌─────────────────────┐\n│ IoC:                │\n│ Agent → Agent →     │\n│ Agent → (ask human) │\n│ → Agent → ...       │\n└─────────────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Agent Starts] --> B{Need Human?}\n    B -->|No| C[Continue]\n    B -->|Yes| D[Ask Human]\n    D --> E[Human Response]\n    E --> C\n    C --> A",
    "when_to_use_ko": ["자율 작업", "배치 처리", "백그라운드 에이전트"],
    "pros_ko": ["높은 처리량", "효율적 인간 시간", "자율 실행"],
    "cons_ko": ["제어 감소", "예상치 못한 행동 위험"]
  },
  {
    "id": "progressive-tool-discovery",
    "title": "Progressive Tool Discovery",
    "title_ko": "점진적 도구 발견",
    "category": "Tool Use & Environment",
    "status": "established",
    "tags": ["mcp", "tool-discovery", "context-optimization"],
    "source": "https://www.anthropic.com/engineering/code-execution-with-mcp",
    "problem": { "en": "Loading all tools upfront wastes context on unused capabilities.", "ko": "모든 도구를 미리 로드하면 사용하지 않는 기능에 컨텍스트가 낭비됩니다." },
    "solution": { "en": "Lazy-load tools based on task requirements, discovering them progressively.", "ko": "작업 요구사항에 따라 도구를 지연 로드하고, 점진적으로 발견합니다." },
    "ascii_diagram": "┌─────────────┐\n│   Task      │\n│ \"Edit file\" │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│ Discover:   │\n│ file_tools  │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│   Load:     │\n│ read, write │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│   Execute   │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Task] --> B{Tool Needed?}\n    B -->|Yes| C[Discover Tool]\n    C --> D[Load Tool]\n    D --> E[Execute]\n    E --> B\n    B -->|No| F[Complete]",
    "when_to_use_ko": ["많은 도구 환경", "컨텍스트 최적화", "MCP 서버"],
    "pros_ko": ["컨텍스트 효율", "빠른 시작", "유연한 확장"],
    "cons_ko": ["발견 지연", "도구 인덱싱 필요"]
  },
  {
    "id": "swarm-migration-pattern",
    "title": "Swarm Migration Pattern",
    "title_ko": "스웜 마이그레이션 패턴",
    "category": "Orchestration & Control",
    "status": "validated-in-production",
    "tags": ["swarm", "map-reduce", "migration", "parallelization"],
    "source": "https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it",
    "problem": { "en": "Large-scale migrations require changes across hundreds of files.", "ko": "대규모 마이그레이션이 수백 개 파일에 걸친 변경을 필요로 합니다." },
    "solution": { "en": "Spawn multiple sub-agents in parallel, each handling a subset of files.", "ko": "여러 서브 에이전트를 병렬로 생성하여 각각 파일 하위 집합을 처리합니다." },
    "ascii_diagram": "┌───────────────┐\n│  Migration    │\n│  1000 files   │\n└───────┬───────┘\n   ┌────┼────┐\n   ▼    ▼    ▼\n┌────┐┌────┐┌────┐\n│S1  ││S2  ││... │\n│100 ││100 ││    │\n│file││file││    │\n└─┬──┘└─┬──┘└─┬──┘\n  └─────┼─────┘\n        ▼\n   ┌─────────┐\n   │ Combine │\n   └─────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Migration Task] --> B[Split Files]\n    B --> C[Sub-Agent 1]\n    B --> D[Sub-Agent 2]\n    B --> E[Sub-Agent N]\n    C & D & E --> F[Merge Results]",
    "when_to_use_ko": ["프레임워크 업그레이드", "API 마이그레이션", "대규모 리팩토링"],
    "pros_ko": ["대규모 병렬화", "빠른 완료", "실패 격리"],
    "cons_ko": ["조정 복잡", "병합 충돌", "비용"]
  },
  {
    "id": "stop-hook-auto-continue-pattern",
    "title": "Stop Hook Auto-Continue Pattern",
    "title_ko": "정지 훅 자동 계속 패턴",
    "category": "Orchestration & Control",
    "status": "emerging",
    "tags": ["hooks", "automation", "testing", "success-criteria"],
    "source": "https://every.to/podcast/transcript-how-to-use-claude-code-like-the-people-who-built-it",
    "problem": { "en": "Agents may stop prematurely before completing all requirements.", "ko": "에이전트가 모든 요구사항을 완료하기 전에 조기에 중지할 수 있습니다." },
    "solution": { "en": "Use stop hooks to verify success criteria before allowing agent termination.", "ko": "에이전트 종료를 허용하기 전에 성공 기준을 확인하는 정지 훅을 사용합니다." },
    "ascii_diagram": "┌─────────────┐\n│   Agent     │\n│  \"Done\"     │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│  Stop Hook  │\n│  Check:     │\n│  - Tests?   │\n│  - Lint?    │\n└──────┬──────┘\n   ┌───┴───┐\n   ▼       ▼\n [Pass]  [Fail]\n   │       │\n   │  ┌────▼────┐\n   │  │Continue │\n   │  │ Working │\n   │  └─────────┘\n   ▼\n┌─────────────┐\n│   Really    │\n│    Done     │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Agent: Done] --> B{Stop Hook}\n    B -->|Pass| C[Really Done]\n    B -->|Fail| D[Continue Working]\n    D --> A",
    "when_to_use_ko": ["테스트 주도 개발", "품질 게이트", "자율 에이전트"],
    "pros_ko": ["완료 보장", "품질 유지", "자동화"],
    "cons_ko": ["무한 루프 위험", "훅 설계 필요"]
  },
  {
    "id": "skill-library-evolution",
    "title": "Skill Library Evolution",
    "title_ko": "스킬 라이브러리 진화",
    "category": "Learning & Adaptation",
    "status": "established",
    "tags": ["code-reuse", "skills", "learning", "capabilities"],
    "source": "https://www.anthropic.com/engineering/code-execution-with-mcp",
    "problem": { "en": "Agents rediscover solutions for previously solved problems.", "ko": "에이전트가 이전에 해결한 문제에 대한 솔루션을 다시 발견합니다." },
    "solution": { "en": "Build and evolve a library of reusable skills that agents can invoke.", "ko": "에이전트가 호출할 수 있는 재사용 가능한 스킬 라이브러리를 구축하고 발전시킵니다." },
    "ascii_diagram": "┌─────────────┐\n│   Task      │\n└──────┬──────┘\n       │\n┌──────▼──────┐\n│Check Library│\n└──────┬──────┘\n   ┌───┴───┐\n   ▼       ▼\n[Found] [Not]\n   │       │\n   │  ┌────▼────┐\n   │  │ Create  │\n   │  │ New Skill│\n   │  └────┬────┘\n   │       │\n   │  ┌────▼────┐\n   │  │ Add to  │\n   │  │ Library │\n   │  └─────────┘\n   ▼\n┌─────────────┐\n│   Execute   │\n│   Skill     │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Task] --> B{Skill Exists?}\n    B -->|Yes| C[Use Skill]\n    B -->|No| D[Create Skill]\n    D --> E[Add to Library]\n    E --> C\n    C --> F[Execute]",
    "when_to_use_ko": ["반복 작업", "팀 공유", "자동화 확장"],
    "pros_ko": ["재사용성", "효율 증가", "지식 축적"],
    "cons_ko": ["관리 오버헤드", "스킬 품질 유지"]
  },
  {
    "id": "rich-feedback-loops",
    "title": "Rich Feedback Loops > Perfect Prompts",
    "title_ko": "완벽한 프롬프트보다 풍부한 피드백 루프",
    "category": "Feedback Loops",
    "status": "validated-in-production",
    "tags": ["feedback", "testing", "reliability"],
    "source": "https://www.nibzard.com/ampcode",
    "problem": { "en": "Crafting perfect prompts is fragile; agents need real feedback to improve.", "ko": "완벽한 프롬프트를 만드는 것은 취약합니다; 에이전트는 개선을 위해 실제 피드백이 필요합니다." },
    "solution": { "en": "Invest in rich feedback mechanisms (tests, linters, CI) over prompt engineering.", "ko": "프롬프트 엔지니어링보다 풍부한 피드백 메커니즘(테스트, 린터, CI)에 투자합니다." },
    "ascii_diagram": "┌──────────────────────┐\n│ Instead of:          │\n│ Perfect Prompt ─────?│\n│                      │\n│ Do this:             │\n│ Agent ──▶ Tests      │\n│        ──▶ Linter    │\n│        ──▶ CI        │\n│        ──▶ Improve   │\n└──────────────────────┘",
    "mermaid_diagram": "flowchart LR\n    A[Agent Output] --> B[Tests]\n    A --> C[Linter]\n    A --> D[CI]\n    B & C & D --> E[Feedback]\n    E --> F[Improve]",
    "when_to_use_ko": ["코딩 에이전트", "품질 중요 작업", "반복 개발"],
    "pros_ko": ["견고함", "지속적 개선", "실제 검증"],
    "cons_ko": ["인프라 필요", "초기 설정 비용"]
  },
  {
    "id": "lethal-trifecta-threat-model",
    "title": "Lethal Trifecta Threat Model",
    "title_ko": "치명적 삼중 위협 모델",
    "category": "Reliability & Eval",
    "status": "best-practice",
    "tags": ["security", "prompt-injection", "threat-model", "data-exfiltration"],
    "source": "https://simonwillison.net/2025/Jun/16/lethal-trifecta/",
    "problem": { "en": "Agents with access to untrusted data, tools, and egress channels are vulnerable.", "ko": "신뢰할 수 없는 데이터, 도구, 송신 채널에 접근하는 에이전트가 취약합니다." },
    "solution": { "en": "Identify and break the lethal trifecta: untrusted data + tool access + exfiltration channel.", "ko": "치명적 삼중: 신뢰할 수 없는 데이터 + 도구 접근 + 송신 채널을 식별하고 차단합니다." },
    "ascii_diagram": "┌─────────────────────────┐\n│   LETHAL TRIFECTA       │\n├─────────────────────────┤\n│ 1. Untrusted Data       │\n│    (emails, web, etc.)  │\n│            +            │\n│ 2. Tool Access          │\n│    (file, API, etc.)    │\n│            +            │\n│ 3. Exfiltration         │\n│    (network, etc.)      │\n│            =            │\n│    SECURITY RISK!       │\n└─────────────────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Untrusted Data] --> D{All Three?}\n    B[Tool Access] --> D\n    C[Exfiltration Channel] --> D\n    D -->|Yes| E[DANGER!]\n    D -->|No| F[Safer]",
    "when_to_use_ko": ["에이전트 보안 설계", "위협 분석", "아키텍처 리뷰"],
    "pros_ko": ["명확한 위협 모델", "방어 우선순위", "설계 가이드"],
    "cons_ko": ["기능 제한 가능", "모든 위협 커버 불가"]
  },
  {
    "id": "llm-map-reduce-pattern",
    "title": "LLM Map-Reduce Pattern",
    "title_ko": "LLM 맵-리듀스 패턴",
    "category": "Orchestration & Control",
    "status": "emerging",
    "tags": ["map-reduce", "sub-agents", "isolation", "untrusted-data"],
    "source": "https://arxiv.org/abs/2506.08837",
    "problem": { "en": "Processing multiple untrusted items in one context risks cross-contamination.", "ko": "하나의 컨텍스트에서 여러 신뢰할 수 없는 항목을 처리하면 교차 오염 위험이 있습니다." },
    "solution": { "en": "Process each item in isolated sub-agent, then reduce results in trusted context.", "ko": "각 항목을 격리된 서브 에이전트에서 처리한 다음, 신뢰할 수 있는 컨텍스트에서 결과를 축소합니다." },
    "ascii_diagram": "┌─────────────┐\n│  Items[]    │\n└──────┬──────┘\n       │ map\n   ┌───┼───┐\n   ▼   ▼   ▼\n┌───┐┌───┐┌───┐\n│S1 ││S2 ││S3 │ (isolated)\n└─┬─┘└─┬─┘└─┬─┘\n  │    │    │\n  └────┼────┘\n       │ reduce\n┌──────▼──────┐\n│   Trusted   │\n│   Context   │\n└─────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Items] -->|Map| B[Sub-Agent 1]\n    A -->|Map| C[Sub-Agent 2]\n    A -->|Map| D[Sub-Agent N]\n    B & C & D -->|Reduce| E[Trusted Aggregator]",
    "when_to_use_ko": ["이메일 처리", "문서 분석", "웹 스크래핑"],
    "pros_ko": ["격리", "병렬 처리", "오염 방지"],
    "cons_ko": ["오버헤드", "조정 복잡"]
  },
  {
    "id": "oracle-and-worker-multi-model",
    "title": "Oracle and Worker Multi-Model Approach",
    "title_ko": "오라클과 워커 멀티 모델 접근법",
    "category": "Orchestration & Control",
    "status": "emerging",
    "tags": ["multi-model", "cost-optimization", "strategic-reasoning"],
    "source": "https://youtu.be/hAEmt-FMyHA?si=6iKcGnTavdQlQKUZ",
    "problem": { "en": "Using expensive models for all tasks is cost-prohibitive.", "ko": "모든 작업에 비싼 모델을 사용하는 것은 비용이 많이 듭니다." },
    "solution": { "en": "Use powerful 'oracle' model for strategy, cheaper 'worker' models for execution.", "ko": "전략에는 강력한 '오라클' 모델을, 실행에는 저렴한 '워커' 모델을 사용합니다." },
    "ascii_diagram": "┌─────────────┐\n│   Oracle    │\n│ (Opus/o3)   │\n│  Strategy   │\n└──────┬──────┘\n       │ plan\n   ┌───┼───┐\n   ▼   ▼   ▼\n┌────┐┌────┐┌────┐\n│W1  ││W2  ││W3  │\n│(Ha)││(Ha)││(Ha)│\n│iku ││iku ││iku │\n└─┬──┘└─┬──┘└─┬──┘\n  └─────┼─────┘\n        ▼\n   ┌─────────┐\n   │ Results │\n   └─────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Oracle: Strategy] --> B[Worker 1]\n    A --> C[Worker 2]\n    A --> D[Worker N]\n    B & C & D --> E[Results]",
    "when_to_use_ko": ["비용 최적화", "대규모 처리", "전략적 작업"],
    "pros_ko": ["비용 절감", "전략 품질", "확장성"],
    "cons_ko": ["아키텍처 복잡", "조정 오버헤드"]
  },
  {
    "id": "verbose-reasoning-transparency",
    "title": "Verbose Reasoning Transparency",
    "title_ko": "상세 추론 투명성",
    "category": "UX & Collaboration",
    "status": "best-practice",
    "tags": ["explainability", "debugging", "transparency", "verbose mode"],
    "source": "https://www.nibzard.com/claude-code",
    "problem": { "en": "Black-box agent outputs are hard to debug and trust.", "ko": "블랙박스 에이전트 출력은 디버깅하고 신뢰하기 어렵습니다." },
    "solution": { "en": "Expose detailed reasoning chains for debugging and verification.", "ko": "디버깅 및 검증을 위해 상세한 추론 체인을 노출합니다." },
    "ascii_diagram": "┌───────────────────────────┐\n│   Verbose Mode            │\n├───────────────────────────┤\n│ Step 1: Analyzing task... │\n│ Step 2: Found files...    │\n│ Step 3: Planning edits... │\n│ Step 4: Executing...      │\n│ Step 5: Verifying...      │\n│                           │\n│ [User can inspect each]   │\n└───────────────────────────┘",
    "mermaid_diagram": "flowchart TD\n    A[Agent] -->|Log| B[Step 1]\n    B -->|Log| C[Step 2]\n    C -->|Log| D[Step N]\n    D --> E[Output]\n    B & C & D --> F[User Inspection]",
    "when_to_use_ko": ["디버깅", "신뢰 구축", "학습 목적"],
    "pros_ko": ["투명성", "디버깅 용이", "신뢰 향상"],
    "cons_ko": ["출력 양 증가", "토큰 비용"]
  }
]
